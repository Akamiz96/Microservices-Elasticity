# üß™ Resultados del experimento `exp1_basic-autoscaling`

Este documento presenta los resultados obtenidos tras la ejecuci√≥n del experimento de elasticidad `exp1_basic-autoscaling`, el cual eval√∫a la respuesta del sistema ante una carga progresiva utilizando el escalamiento autom√°tico basado en uso de CPU (HPA).

Se incluyen visualizaciones detalladas del comportamiento del sistema (uso de CPU, n√∫mero de pods, curvas de elasticidad, etc.) as√≠ como m√©tricas cuantitativas que permiten analizar la eficiencia, precisi√≥n y adaptabilidad del mecanismo de escalado configurado.

Los datos y gr√°ficos aqu√≠ mostrados han sido generados autom√°ticamente a partir de los logs recolectados y procesados por los scripts incluidos en la carpeta `analysis/` del proyecto.

---

## üìà Gr√°ficos de comportamiento

En esta secci√≥n se presentan los principales gr√°ficos generados a partir del experimento, que permiten visualizar c√≥mo vari√≥ el comportamiento del sistema a lo largo del tiempo. Estos gr√°ficos son esenciales para comprender:

- C√≥mo reaccionaron los pods al aumento y disminuci√≥n de carga.
- Cu√°ndo ocurrieron los eventos de escalamiento.
- C√≥mo se distribuy√≥ el uso de CPU entre las r√©plicas activas.

---

### üî∏ Uso de CPU por pod

Estos gr√°ficos muestran el porcentaje de uso de CPU de los pods NGINX desplegados durante la prueba. El HPA toma decisiones basadas en el promedio de uso de CPU, por lo tanto, observar estos valores por pod permite entender c√≥mo y cu√°ndo el sistema decide escalar.

#### üîπ Uso combinado de CPU por todos los pods

- **cpu_usage_per_pod.png**  
  Este gr√°fico muestra el uso de CPU agrupado por pod a lo largo del tiempo. Se observa un aumento progresivo hasta que se alcanza el pico de carga, seguido por una disminuci√≥n controlada que refleja la reducci√≥n de usuarios virtuales.

  ![cpu_usage_per_pod](images/basic-autoscaling/cpu_pod/cpu_usage_per_pod.png)

- **cpu_usage_per_pod_with_events.png**  
  Es la misma visualizaci√≥n anterior pero incluye anotaciones visuales (l√≠neas verticales) que indican los eventos de escalamiento ocurridos. Esto permite correlacionar el aumento/disminuci√≥n de uso de CPU con la acci√≥n del HPA.

  ![cpu_usage_per_pod_with_events](images/basic-autoscaling/cpu_pod/cpu_usage_per_pod_with_events.png)

#### üîπ Uso de CPU individual por pod

- **pod1_cpu.png** y **pod2_cpu.png**  
  Estos gr√°ficos permiten observar c√≥mo se comport√≥ cada pod individual. Pod1 absorbe la carga inicial y permanece activo durante gran parte del experimento. Pod2 se activa posteriormente cuando el HPA escala el sistema, y se observa su participaci√≥n en la distribuci√≥n de carga.

  ![pod1_cpu](images/basic-autoscaling/cpu_pod/pod1_cpu.png)
  ![pod2_cpu](images/basic-autoscaling/cpu_pod/pod2_cpu.png)

- **pod1_cpu_with_events.png** y **pod2_cpu_with_events.png**  
  Aqu√≠ se visualiza el mismo comportamiento anterior, pero a√±adiendo los eventos de escalamiento, lo que ayuda a identificar con precisi√≥n cu√°ndo fue creado o eliminado cada pod y c√≥mo impact√≥ en su uso de CPU.

  ![pod1_cpu_with_events](images/basic-autoscaling/cpu_pod/pod1_cpu_with_events.png)
  ![pod2_cpu_with_events](images/basic-autoscaling/cpu_pod/pod2_cpu_with_events.png)

> üóÇÔ∏è **Ubicaci√≥n de las im√°genes**: todas estas gr√°ficas se generan autom√°ticamente tras ejecutar el experimento y se almacenan en la carpeta `analysis/images/basic-autoscaling/cpu_pod/`.  
> ‚ö†Ô∏è Los resultados pueden variar levemente dependiendo de las condiciones del entorno de ejecuci√≥n (capacidad del cl√∫ster, latencia de red, etc.).

---

### üî∏ N√∫mero de pods activos

Estos gr√°ficos muestran la evoluci√≥n del n√∫mero de r√©plicas del microservicio a lo largo del tiempo. Esta m√©trica es clave para entender c√≥mo el HPA respondi√≥ a la carga generada y en qu√© momento se activaron o desactivaron nuevas instancias (pods).

#### üîπ Evoluci√≥n sin eventos

- **pod_count_over_time.png**  
  En este gr√°fico se observa que el sistema inicia con una sola r√©plica, y se mantiene as√≠ durante los primeros minutos del experimento. Posteriormente, se incrementa el n√∫mero de pods a 2, permaneciendo en ese estado hasta el final de la prueba. Esta respuesta refleja la reacci√≥n del HPA ante el aumento sostenido del uso de CPU.

  ![pod_count_over_time](images/basic-autoscaling/pod_count/pod_count_over_time.png)

#### üîπ Evoluci√≥n con eventos de escalamiento

- **pod_count_over_time_with_events.png**  
  Esta versi√≥n incluye l√≠neas verticales que marcan los eventos de escalamiento detectados en el cl√∫ster. Se puede apreciar claramente el momento exacto en que ocurre el `scaleup`, lo que ayuda a sincronizar visualmente esta acci√≥n con los gr√°ficos de CPU y demanda. No se observa `scaledown`, lo cual indica que el sistema permaneci√≥ con dos r√©plicas hasta el final del experimento.

  ![pod_count_over_time_with_events](images/basic-autoscaling/pod_count/pod_count_over_time_with_events.png)

> üóÇÔ∏è **Ubicaci√≥n de las im√°genes**: estos gr√°ficos se generan autom√°ticamente y se almacenan en `analysis/images/basic-autoscaling/pod_count/`.  
> ‚ö†Ô∏è La respuesta del HPA puede variar dependiendo de la configuraci√≥n del cl√∫ster y los recursos disponibles en el entorno de ejecuci√≥n.

---

### üî∏ Curvas de elasticidad

Las siguientes gr√°ficas permiten visualizar la relaci√≥n entre la demanda estimada de CPU y la oferta real proporcionada por el sistema en cada instante del experimento. Estas curvas son fundamentales para evaluar qu√© tan eficientemente el sistema respondi√≥ al cambio de carga, y en qu√© medida logr√≥ mantenerse cercano a la demanda real sin sobreaprovisionar ni quedar corto de recursos.

Las curvas comparan dos se√±ales:

- **Demanda estimada** (l√≠nea roja): calculada a partir del n√∫mero de VUs o requests y su consumo estimado de CPU seg√∫n el microbenchmark.
- **Oferta observada** (l√≠nea azul): calculada en funci√≥n del n√∫mero de r√©plicas activas y el `CPU request` de cada pod.

Las zonas sombreadas indican:

- **Underprovisioning** (naranja): la demanda supera la oferta ‚Üí riesgo de degradaci√≥n del servicio.
- **Overprovisioning** (celeste): la oferta supera la demanda ‚Üí recursos desaprovechados.

#### üîπ Basada en VUs

- **elasticity_curve_vu.png**  
  Se observa una demanda creciente en forma de pir√°mide, con una oferta que responde m√°s lentamente. El √°rea naranja refleja subaprovisionamiento durante gran parte del experimento.

  ![elasticity_curve_vu](images/basic-autoscaling/elasticity/elasticity_curve_vu.png)

- **elasticity_curve_vus_with_events.png**  
  Esta versi√≥n incluye eventos de escalamiento. Se puede ver c√≥mo la oferta comienza a subir luego del evento de `scaleup`, pero no alcanza completamente la demanda, lo cual refleja un retraso caracter√≠stico del HPA.

  ![elasticity_curve_vus_with_events](images/basic-autoscaling/elasticity/elasticity_curve_vus_with_events.png)

#### üîπ Basada en requests

- **elasticity_curve_req.png**  
  Esta versi√≥n utiliza como base el n√∫mero real de requests por segundo. La demanda sigue una forma similar pero con menor magnitud. La brecha con la oferta se reduce, aunque sigue existiendo un √°rea importante de subaprovisionamiento.

  ![elasticity_curve_req](images/basic-autoscaling/elasticity/elasticity_curve_req.png)

- **elasticity_curve_reqs_with_events.png**  
  Con los eventos marcados, es evidente c√≥mo la oferta mejora su alineaci√≥n tras el `scaleup`, aunque no se alcanza una coincidencia exacta. Al final del experimento se detecta una ligera zona azul que indica `overprovisioning`.

  ![elasticity_curve_reqs_with_events](images/basic-autoscaling/elasticity/elasticity_curve_reqs_with_events.png)

> üóÇÔ∏è **Ubicaci√≥n de las im√°genes**: estas gr√°ficas se encuentran en `analysis/images/basic-autoscaling/elasticity/` y se generan autom√°ticamente tras la ejecuci√≥n del an√°lisis.  
> ‚ö†Ô∏è Las curvas pueden variar en funci√≥n de los valores definidos en el microbenchmark y del comportamiento puntual del cl√∫ster durante el experimento.

---

### üî∏ M√©tricas complementarias

Adem√°s del an√°lisis de uso de CPU y n√∫mero de pods, tambi√©n se evaluaron m√©tricas que permiten medir la calidad del servicio entregado por el sistema bajo condiciones variables de carga. Estas m√©tricas fueron recolectadas directamente desde los resultados de k6 y procesadas autom√°ticamente.

#### üîπ Latencia promedio

- **latency_avg.png**  
  El gr√°fico muestra una latencia que se estabiliza r√°pidamente tras un pico inicial, manteni√©ndose en torno a 500-600 ms durante la mayor parte del experimento. Esto indica un comportamiento estable frente a la carga.

  ![latency_avg](images/basic-autoscaling/indirect_metrics/latency_avg.png)

- **latency_avg_events.png**  
  Aqu√≠ se aprecia c√≥mo el evento de escalamiento (`scaleup`) ocurre cuando la latencia ya se ha estabilizado, lo que sugiere que el sistema logra mantener buenos tiempos de respuesta incluso antes de escalar.

  ![latency_avg_events](images/basic-autoscaling/indirect_metrics/latency_avg_events.png)

#### üîπ Throughput total (requests por segundo)

- **throughput.png**  
  La tasa de procesamiento se mantiene constante en 1 request/segundo, lo que concuerda con el dise√±o del microbenchmark, donde cada VU realiza 1 request por segundo.

  ![throughput](images/basic-autoscaling/indirect_metrics/throughput.png)

- **throughput_events.png**  
  Esta versi√≥n muestra que el escalamiento no afecta la tasa de throughput, confirmando que el sistema fue capaz de sostener la carga sin interrupciones.

  ![throughput_events](images/basic-autoscaling/indirect_metrics/throughput_events.png)

#### üîπ Relaci√≥n entre VUs y Throughput

- **throughput_vs_vus.png**  
  El gr√°fico confirma que el throughput crece de forma lineal con el n√∫mero de VUs, manteni√©ndose en 1 request por VU. Esto sugiere una relaci√≥n directa sin cuellos de botella evidentes.

  ![throughput_vs_vus](images/basic-autoscaling/indirect_metrics/throughput_vs_vus.png)

#### üîπ Errores HTTP

- **http_errors.png**  
  No se registran errores HTTP durante la prueba. La l√≠nea permanece en 0, lo cual indica una correcta disponibilidad del servicio bajo carga.

  ![http_errors](images/basic-autoscaling/indirect_metrics/http_errors.png)

- **http_errors_events.png**  
  El gr√°fico con eventos corrobora que no hubo errores ni durante ni despu√©s del escalamiento, lo que sugiere que el proceso de escalado fue transparente para los usuarios.

  ![http_errors_events](images/basic-autoscaling/indirect_metrics/http_errors_events.png)

> üóÇÔ∏è **Ubicaci√≥n de las im√°genes**: estas gr√°ficas est√°n disponibles en `analysis/images/basic-autoscaling/indirect_metrics/` y se generan autom√°ticamente al ejecutar el an√°lisis del experimento.
> ‚ö†Ô∏è Las curvas pueden variar en funci√≥n de los valores definidos en el microbenchmark y del comportamiento puntual del cl√∫ster durante el experimento.

---

## üìä M√©tricas cuantitativas de elasticidad

A continuaci√≥n se presentan las m√©tricas derivadas del an√°lisis de oferta y demanda de CPU, que permiten cuantificar el nivel de elasticidad alcanzado por el sistema. Se ofrecen dos variantes del c√°lculo:

- Basado en usuarios virtuales (VUs)
- Basado en n√∫mero de requests por segundo

Estas m√©tricas se obtienen directamente de los archivos generados por el an√°lisis posterior y permiten comparar el comportamiento del sistema desde dos perspectivas distintas.

---

### üßÆ Definici√≥n de m√©tricas de elasticidad

Las siguientes m√©tricas permiten evaluar cuantitativamente el comportamiento el√°stico del sistema bajo prueba. Se agrupan en bloques para facilitar su comprensi√≥n:

#### üîπ 1. Recursos acumulados

- **Œ£U (millicore¬∑s)**: CPU faltante acumulada durante per√≠odos de subaprovisionamiento.
- **Œ£O (millicore¬∑s)**: CPU excedente acumulada durante per√≠odos de sobreaprovisionamiento.

#### üîπ 2. Tiempos de aprovisionamiento

- **Œ£A (s)**: Tiempo total en subaprovisionamiento.
- **AÃÖ (veces)**: Promedio de ocurrencias en estado subaprovisionado.
- **≈™ (millicores)**: CPU promedio faltante.
- **Œ£B (s)**: Tiempo total en sobreaprovisionamiento.
- **BÃÖ (veces)**: Promedio de ocurrencias en estado sobreaprovisionado.
- **≈å (millicores)**: CPU promedio excedente.

#### üîπ 3. Reconfiguraci√≥n del sistema

- **Œ∏ (s)**: Tiempo total en que el sistema cambi√≥ de n√∫mero de pods.
- **Eventos detectados**: bloques de escalado hacia arriba o hacia abajo.

#### üîπ 4. Precisi√≥n de escalado

- **P·µ§ (millicore/s)**: Precisi√≥n de escalado hacia arriba.
- **Pùëë (millicore/s)**: Precisi√≥n de escalado hacia abajo.

#### üîπ 5. Elasticidad relativa

- **E·µ§ (adimensional)**: Elasticidad de subida.
- **Eùëë (adimensional)**: Elasticidad de bajada.
- **E‚Çó (adimensional)**: Elasticidad global combinada.

#### üîπ 6. M√©tricas complementarias

- **E (millicore/s)**: Eficiencia global (idealmente cercana a cero).
- **R_U / R_O (millicore/s)**: Sub y sobreaprovisionamiento relativo por segundo.
- **% Œ∏**: Porcentaje del tiempo total que el sistema estuvo reconfigur√°ndose.
- **% tiempo √∫til**: Tiempo restante operativo sin cambios de configuraci√≥n.

---

### üîπ M√©tricas basadas en VUs

Esta variante estima la demanda a partir del n√∫mero de VUs activos por segundo (`cpu_per_vu`), representando una visi√≥n abstracta del comportamiento.

- **Duraci√≥n total:** 410 s
- **Œ£U / Œ£O:** 39000.00 / 0.00 millicore¬∑s
- **Œ£A / AÃÖ / ≈™:** 410.00 s / 1.00 / 95.12 millicores
- **Œ£B / BÃÖ / ≈å:** 0.00 s / 0.00 / 0.00 millicores
- **P·µ§ / Pùëë:** 95.12 / 0.00 millicore/s
- **E·µ§ / Eùëë / E‚Çó:** 0.0105 / 0.0000 / 0.4415
- **Œ∏:** 1.00 s (0.24 %)
- **E:** ‚Äì94.1220 millicore/s
- **R_U / R_O:** 95.12 / 0.00 millicore/s
- **% tiempo √∫til:** 99.76 %

El sistema permaneci√≥ todo el experimento en estado de subaprovisionamiento, sin escalar hacia abajo. La baja elasticidad refleja un desfase entre la demanda estimada por VUs y la capacidad de respuesta del HPA.

---

### üîπ M√©tricas basadas en Requests

Esta variante estima la demanda usando el throughput real (`cpu_per_req`). Permite una visi√≥n m√°s alineada con lo que realmente procesa el sistema.

- **Duraci√≥n total:** 410 s
- **Œ£U / Œ£O:** 6260.00 / 100.00 millicore¬∑s
- **Œ£A / AÃÖ / ≈™:** 370.00 s / 0.90 / 16.92 millicores
- **Œ£B / BÃÖ / ≈å:** 40.00 s / 0.10 / 2.50 millicores
- **P·µ§ / Pùëë:** 15.27 / 0.24 millicore/s
- **E·µ§ / Eùëë / E‚Çó:** 0.0655 / 4.1000 / 2.7075
- **Œ∏:** 1.00 s (0.24 %)
- **E:** ‚Äì14.5122 millicore/s
- **R_U / R_O:** 15.27 / 0.24 millicore/s
- **% tiempo √∫til:** 99.76 %

En esta perspectiva se detecta una mayor eficiencia. El sistema logra acercarse m√°s a la demanda real, con presencia tanto de sub como de sobreaprovisionamiento, y mejor respuesta en escalamiento descendente.

---

### üìã Comparaci√≥n de m√©tricas

| M√©trica                           | Unidad             | VUs                     | Requests                |
|----------------------------------|---------------------|--------------------------|--------------------------|
| Œ£U / Œ£O                          | millicore¬∑s         | 39000.00 / 0.00          | 6260.00 / 100.00         |
| ≈™ / ≈å                            | millicores          | 95.12 / 0.00             | 16.92 / 2.50             |
| AÃÖ / BÃÖ                          | veces               | 1.00 / 0.00              | 0.90 / 0.10              |
| P·µ§ / Pùëë                          | millicore/s         | 95.12 / 0.00             | 15.27 / 0.24             |
| E·µ§ / Eùëë / E‚Çó                    | adimensional        | 0.0105 / 0.0000 / 0.4415 | 0.0655 / 4.1000 / 2.7075 |
| Œ∏                                | segundos            | 1.00                     | 1.00                     |
| R_U / R_O                        | millicore/s         | 95.12 / 0.00             | 15.27 / 0.24             |
| % tiempo √∫til                    | porcentaje          | 99.76 %                  | 99.76 %                  |
| E                                | millicore/s         | ‚Äì94.1220                 | ‚Äì14.5122                 |

> üìå Estas diferencias muestran c√≥mo el enfoque basado en requests puede representar de forma m√°s realista el desempe√±o del sistema frente a la carga procesada.

---

### üìÇ Archivos generados

Los resultados num√©ricos se encuentran en:

- `basic-autoscaling/output/elasticity_metrics_vus.txt`
- `basic-autoscaling/output/elasticity_metrics_requests.txt`

> ‚ö†Ô∏è **Importante:**  
> Los valores obtenidos pueden cambiar en funci√≥n de:
> - Los par√°metros definidos en el microbenchmark.
> - El comportamiento del cl√∫ster al momento de la ejecuci√≥n.
> - La cantidad y tipo de carga generada por k6.

Es recomendable mantener condiciones constantes entre ejecuciones para hacer comparaciones v√°lidas.

---